---
title: 非线性方程求根算法设计
date: 2018-2-22
tags: [Matlab, Iteration]
mathjax: true
categories: 课程设计
---

线性方程是方程式中仅包含未知量的一次方项和常数项的方程，除此之外的方程都是非线性方程，非线性线性方程的求解是数值计算领域的一个重要问题。本文主要表述非线性方程求根方法，用数值方法求得满足一定精度要求的近似解，利用不同的方法来求解非线性方程，然后比较和分析不同方法。

<!-- more -->

####  线性收敛不动点迭代法

##### 方法实现

原方程为：$x^3+2x^2+10x-20=0$,非线性方程可以有以下的改造方式，从而得到不同的迭代函数。原函数：
$$
φ(x)=x^3+2x^2+10x-20
$$
I．$x=\frac{20}{(x^2+2x+10)}$对应的迭代方法$x_{k+1}=  φ_1 (x_k )=\frac{20}{(x_k^2+2x_k+10)}$

II.  $x=\sqrt{\frac{20}{(x+2+\frac{10}{x})}}$对应迭代方法 $x_{k+1}= φ_2 (x_k )=\sqrt{\frac{20}{(x_k+2+\frac{10}{x_k })}}$

粗略估计根的范围。

此非线性方程只有一个实根，其余两个为虚根。

![NonlinearEquations](http://image-1252432001.coscd.myqcloud.com/NonlinearEquations.jpg)

实根的大致范围在(0,2)之间。

判断收敛性
$$
φ(1)<0;      φ(1.5)>0
$$
根据两个迭代函数I，II，判断迭代函数的一阶导数，在[1,1.5]的最大绝对值。
$$
Max |φ_{1}^{'} |≈ 0.47337
$$

$$
Max |φ_2^{'} |≈ 0.42935
$$

满足不动点收敛定理，两个迭代函数都收敛。

利用matlab迭代：

```matlab
function result = aciter(func)
x = 1.25;

times = 0;
for i=1:100
    check = x;
    x = feval(func, x);
    disp(x);
if abs(check - x) < 1e-15
break;
end
    times = times + 1;
end
result = x;
disp(times);

```

```matlab
format long;
x = sym('x');
fours = '20/(x^2+2*x+10)';
sevens = 'sqrt(20/(x+2+10/x))';

% 未加速迭代
aciter(inline(fours));
aciter(inline(sevens));
```

结果如下



$φ_1$迭代41次，最终收敛于$x^*=1.368808107821373$

$φ_2$迭代26次，最终收敛于$x^*=1.368808107821373$

##### 结果分析

根据非线性方程来改造不同的迭代函数，然后迭代，可以得到近似解，然而迭代收敛速度比较慢。

#### 加速法

##### 实现方法

加速法可以构造新的不动点函数，迭代收敛速度非常快。

首先，构造新的不动点函数。
$$
-0.47337 ≈ φ_1^{'}(1)≤ φ_1^{'}(x)  ≤  φ_1^{'} (1.5) ≈  -0.42999
$$
因此，可以看出导数变化并不大

令$L=\frac{(-0.42999+ -0.47337)}{2}= -0.45168$ , 新的加速迭代方法为$x=\frac{(φ_1 (x)-Lx)}{(1-L)}$

同理验证可以得到的$φ_2$新的不动点函数，然后利用新的不动点函数进行迭代。

```matlab
format long;
x = sym('x');
%构造不同的迭代方法
fours = '20/(x^2+2*x+10)';
sevens = 'sqrt(20/(x+2+10/x))';
%求其一阶导数
dffour = inline(diff(fours, x));
dfseven = inline(diff(sevens, x));

% 加速方法
sevenL = (dfseven(1.5) + dfseven(1))/2;
fourL = (dffour(1.5) + dffour(1))/2;
%构造加速法新的迭代函数
FourIter = (fours - fourL*x)/(1 - fourL);
SevenIter = (sevens - sevenL*x)/(1 - sevenL);

% 未加速的迭代
% aciter(inline(fours));
% aciter(inline(sevens));

% 加速迭代
aciter(inline(FourIter));
aciter(inline(SevenIter));
```

##### 结果分析

最终两个迭代函数都收敛于$x^*= 1.368808107821373$,对比未使用加速法的迭代函数：

| 迭代次数(达到收敛) | 未加速 | 加速 |
| ------------------ | ------ | ---- |
| $φ_1$              | 41     | 6    |
| $φ_2$              | 26     | 13   |

可见迭代加速对迭代次数有着很大的提升。

#### 二分法

##### 实现方法

二分法求解非线性方程的近似解，将零点存在的区间，每次把区间二等分，给出两个等分区间中有根的那个区间，达到把区间缩小的目的，那么区间的中点就是一个很好的近似解。但是二分法的计算效率不够高。

##### 算法流程

利用伪码描述算法流程

```mathematica
输入：a, b, 函数 f(x) ; 输出：x. 
While (𝑏 − 𝑎) >𝜀 do 
𝑥:= 𝑎 + (𝑏 − 𝑎)/2 ;
If sign(𝑓(𝑥)) = sign(𝑓(𝑎)) then 
𝑎:= 𝑥 ; 
Else 
𝑏: = 𝑥 ; 
End 
End 
𝑥:= 𝑎 + (𝑏 − 𝑎)/2 .
% sign()表示取符号的函数
%而二分迭代结束的条件为有根区间(a, b)的长度小于某个阈值𝜀. 
%浮点运算中几乎不可能出现等于 0 的情况
%所以sign()函数的结果只是正号、或负号
```

```matlab
% 二分法
format long;
f = inline('x^3+2*x^2+10*x-20');
% 估计根的区间
% ezplot('x^3+2*x^2+10*x-20'); 
% grid on;
a = 0;
b = 2;
% 设置精度
tol = 1e-15;

k = 1;
while true
    A(k) = a;
    B(k) = b;
    ya = feval(f, a);
    yb = feval(f, b);
    temp = (a+b)/2;
    M(k) = temp;
    yt = feval(f, temp);
if abs(yt) <tol
break;
end
if yt*ya < 0
        a = a;
        b = temp;
elseif yt*yb < 0
        a = temp;
        b = b;
end
    k = k + 1;
end
```

##### 结果分析

程序运行后，迭代48次后，最终收敛于$x^* = 1.368808107821373$

二分法效率较差，但是简单易懂。

#### 牛顿迭代法

##### 实现方法

牛顿法实际上就是迭代函数为$\varphi(x)=x- \frac{f(x)}{f^{'}(x)}$的不动点迭代法，牛顿法也可以看成一种特别的加速方法。牛顿法也依赖初值的选取。

##### 结果分析

其算法流程本质就是迭代

```matlab
function result = Newton(x0)
format long;

% 牛顿迭代法
syms x;
fu(x) = x^3+2*x^2+10*x-20;
df = diff(fu,x);
fun = x - fu/df;
func = inline(fun);
% 开始迭代
times = 0;
for i = 1:100
    checks = x0;
    x0 = feval(func, x0);
if abs(checks - x0) < 1e-15
break;
end
    times = times + 1;
end
disp(times);
result = x0;
```

牛顿法依赖初值的选取，对于不同的初值，迭代次数如下

| 初值     | 100  | 10   | 1    | 1.3  | 0    | -10  | -100 |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 迭代次数 | 14   | 8    | 5    | 4    | 6    | 8    | 15   |

![imgs](http://image-1252432001.coscd.myqcloud.com/NonlinearEquationsNewton.jpg)

可见初值的选取，会影响迭代次数.

#### 割线法

##### 实现方法

牛顿法计算时，需要计算导数，在某些情景下，会有很大的计算量，割线法使用近似计算的方法代替牛顿法中的导数，不需要计算导数，避免了在某些情景下导数的计算量很大的问题。也是一种不动点迭代方法。

迭代函数：
$$
x_{k+1}=x_k- \frac{f(x_k )(x_k-x_{k-1} )} {f(x_k )-f(x_{k-1} ) }
$$

##### 结果分析

```matlab
format long;
f = inline('x^3+2*x^2+10*x-20');
% 估计根的区间
% ezplot('x^3+2*x^2+10*x-20'); 
% grid on;

% 割线法
a(i) = 0;
b(i) = 2;

x = b(i);
i = 1;
%设置迭代次数
while i<10
%迭代函数
    x = b(i) - (b(i) - a(i))/(feval(f, b(i))-feval(f, a(i)))*feval(f, b(i));
    disp(x);
    i = i + 1;
    a(i) = b(i - 1);
    b(i) = x;
end
```

10次迭代结果如下:

| 1.111111111111111 | 2    |
| ----------------- | ---- |
| 1.324296141814390 | 3    |
| 1.372252278803517 | 4    |
| 1.368763504207928 | 5    |
| 1.368808063373287 | 6    |
| 1.368808107821947 | 7    |
| 1.368808107821373 | 8    |
| 1.368808107821373 | 9    |
| NaN               | 10   |

程序在8次迭代时就得到了较为准确的解，迭代效果不错.

#### 算法分析与比较

##### 结果综述

根据以上方法的结果可得：

| 迭代方法           | 线性收敛不动点迭代 | 线性收敛不动点迭代(加速) | 二分法 | 牛顿法 | 割线法 |
| ------------------ | ------------------ | ------------------------ | ------ | ------ | ------ |
| 迭代次数  (最优的) | 26                 | 6                        | 48     | 4      | 8      |

可见初值选择合适的牛顿迭代，效率非常高。构造合适的迭代函数，然后加速计算效率也是非常可观的。

##### 牛顿法综述

但是“合适”有时是很模糊的，牛顿法在近似解附近收敛速度非常快，也说明牛顿法对初值的选取是很敏感的，而且牛顿法需要求导，有些时候导数并不好求，这也限制了牛顿的适用范围。为了防止牛顿法发散，加入条件$|f(x_(k+1) )|<|f(x_k )|$,要求单减，可以改进牛顿法，即牛顿下山法。

##### 二分法综述

优点很明显，简单易用，并且因为在不断的分割区间，所以总是收敛的。

缺点也很明显，收敛速度很慢，不能求复根，还要已知近似解的上下界，给定近似解的区间。

##### 割线法综述

割线法算是牛顿法一种变形，不用求导，避免有些函数不易求导。但需要两步的值，收敛速度也很快，且不用给定初值。

##### 不动点迭代综述

不动点迭代法，因为可以有多种迭代函数，所以产生的迭代序列有可能收敛快，也可能收敛慢，也可能不收敛。对于收敛的迭代序列，利用加速法计算能提高收敛速度，其实牛顿法，割线法都可以看成一种不动点迭代，牛顿法也是一种加速方法。



#### 参考文献

[1]同济大学计算数学教研室，现代数值计算第2版，北京：人民邮电出版，2014年。

[2]喻文健 , 数值分析与算法，北京：清华大学出版社，2012年。

[3]许振华， 数值分析实验指导书，郑州：郑州轻工业学院，2017。

